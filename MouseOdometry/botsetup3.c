#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl2,  xEncoder,       sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  yEncoder,       sensorQuadEncoder)
#pragma config(Motor,  port2,           lBack,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           lFront,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rFront,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rBack,         tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define rf motor[rFront]
#define rb motor[rBack]
#define lf motor[lFront]
#define lb motor[lBack]
#define motors  rf=rb=lf=lb
#define mtrs  rf=rb=lf=lb
#define rotation SensorValue[gyro]
#define movespeed 50
#define toTimer = time1[T1]

#ifdef datalog
#pragma DebuggerWindows("DatalogGraph")
#endif

typedef struct{
	float x_pos;
	float y_pos;
}BotLocation;

typedef enum dirco {pos = 1,neg = -1} dircoeff ;

typedef struct{
	int x_quad;
	int y_quad;
	float wheelcirc;
	float xticks;
	float yticks;
	dircoeff ydir;
	dircoeff xdir ;

} odometry;


typedef struct{
	int right_front_motor;
	int right_rear_motor;
	int left_front_motor;
	int left_rear_motor;
	int destination_x;
	int destination_y;
	int movement_timeout;
	int movement_tolerance;
} odometry_go;



odometry odom;
odometry_go ogo;

BotLocation botpos;

bool between(float val, float top, float bottom){
	if (val < top && val > bottom ) return true;
	else return false;
}

void stop()
{
	if(lf>0)
		motors = -100;
	else
		motors = 100;
	wait1Msec(70);
	motors = 0;
}

void right()
{
	rf = -movespeed;
	rb = movespeed;
	lf = movespeed;
	lb = -movespeed;
}

void left()
{
	rf = movespeed;
	rb = -movespeed;
	lf = -movespeed;
	lb = movespeed;
}

void forward()
{
	rf = movespeed;
	rb = movespeed;
	lf = movespeed;
	lb = movespeed;
}

void reverse()
{
	rf = -movespeed;
	rb = -movespeed;
	lf = -movespeed;
	lb = -movespeed;
}

void rotate_left(float degrees)
{
	rotation = 0;
	rf = movespeed;
	rb = movespeed;
	lf = -movespeed;
	lb = -movespeed;
	while (rotation*(90.0/64.0) > -10 * degrees)
	{  	writeDebugStreamLine("rotate left  %f  %f   %f",degrees,rotation,-10 * degrees);}
	rf = 0;
	rb = 0;
	lf = 0;
	lb = 0;
}


void rotate_right(float degrees)
{
	writeDebugStreamLine("Rotataing");
	rotation = 0;
	writeDebugStreamLine("rotate right - %f - %f",degrees,rotation);
	rf = -movespeed;
	rb = -movespeed;
	lf = movespeed;
	lb = movespeed;
	while (rotation*(90.0/64.0) < (degrees*10))
	{
		writeDebugStreamLine ("Right- %f", rotation	);
	}
	rf = 0;
	rb = 0;
	lf = 0;
	lb = 0;
}

void process()
{
	rotate_left(180);
	wait1Msec(2000);
	rotate_right(180);
	wait1Msec(2000);

}




task odometer()
{
	float xq, yq;
	SensorValue[odom.x_quad] = SensorValue[odom.y_quad]  = 0.0;
	xq = yq = 0.0;
	while(1)
	{
		xq =  SensorValue[odom.x_quad]/odom.xticks*odom.wheelcirc*odom.xdir;
		yq =  SensorValue[odom.y_quad]/odom.yticks*odom.wheelcirc*odom.ydir;
		botpos.x_pos += xq;
		botpos.y_pos += yq;
#ifdef datalog
		datalogDataGroupStart();
		datalogAddValue( 0, botpos.x_pos );
		datalogAddValue(1, botpos.y_pos );
		datalogDataGroupEnd();
#endif
		SensorValue[odom.x_quad] = SensorValue[odom.y_quad]  = 0.0;
		wait1Msec(100);
	}
}

void reset_odometry()
{
	botpos.x_pos = botpos.y_pos  = 0.0;
	odom.x_quad = odom.y_quad = 0;
}

void init_odometry(int x_quad, int y_quad, float whlcir = 9.42, float xtck = 360.0, float ytck = 360.0, dircoeff xdir = pos, dircoeff ydir  = pos)
{
	/*  if((ydir != 1 || ydir != -1) && (xdir != 1 || xdir != -1))
	{
	writeDebugStream("Invalid Value for direction multipliear!");
	}*/
	odom.x_quad = x_quad;
	odom.y_quad = y_quad;
	odom.wheelcirc = whlcir;
	odom.xticks = xtck;
	odom.yticks = ytck;
	odom.xdir = xdir;
	odom.ydir = ydir;
	startTask(odometer);
#ifdef datalog
	datalogClear();
#endif
}
void get_botlocation(BotLocation *bl)
{
	bl->x_pos = botpos.x_pos;
	bl->y_pos = -botpos.y_pos;
}

void init_odometry_go(int lfront, int lrear, int rfront, int rrear, int tolerance = 1)
{
	ogo.right_front_motor = rfront;
	ogo.right_rear_motor = rrear;
	ogo.left_front_motor = lfront;
	ogo.left_rear_motor = rrear;
	ogo.movement_tolerance = tolerance;
}


void odometry_go_execute(int dest_x, int dest_y, int timeout=30000, int method=1)
{
	int dest_reached;
	int direction_x, direction_y;
	BotLocation pos;
	ogo.destination_x = dest_x;
	ogo.destination_y = dest_y;
	ogo.movement_timeout = timeout;
	dest_reached = 0;
	clearTimer(T1);


	get_botlocation(&pos);
	if(pos.x_pos > ogo.destination_x)
		direction_x = -1.0;
	if(pos.x_pos < ogo.destination_x )
		direction_x = 1.0;
	if(pos.y_pos > ogo.destination_y )
		direction_y = -1.0;
	if(pos.y_pos < ogo.destination_y)
		direction_y = 1.0;
	while(time1(T1) < ogo.movement_timeout && dest_reached == 0)
	{
		get_botlocation(&pos);
		while(!between(pos.y_pos, ogo.destination_y+1.0,ogo.destination_y-1.0 ) )
		{
			get_botlocation(&pos);
			writeDebugStreamLine("odom %f %f %f %f\r",pos.x_pos,pos.y_pos,ogo.destination_y+1.0,ogo.destination_y-1.0);
			if (motor[rFront]== 0){
				if (ogo.destination_y > pos.y_pos)
				{
					forward();
				}
				else
				{
					reverse();
				}
			}
			//		if(! ((abs(pos.y_pos) < abs(ogo.destination_y -1.0))||(abs(pos.y_pos) > abs(ogo.destination_y +1.0))) ){
			if( between(pos.y_pos, ogo.destination_y+1.0,ogo.destination_y-1.0 )){
				dest_reached = 1;
				stop();

			}
		}
		wait1Msec(3000);
		while(!between(pos.x_pos, ogo.destination_x+1.0,ogo.destination_x-1.0 ))
		{
			get_botlocation(&pos);
			writeDebugStreamLine("Left %f %f %f %f\r",pos.x_pos,pos.y_pos,ogo.destination_x+1.0,ogo.destination_x-1.0);
			if (motor[rFront]== 0){
				if (ogo.destination_x > pos.x_pos)
				{
					left();
				}
				else
				{
					right();
			}}
			if( between(pos.x_pos, ogo.destination_x+1.0,ogo.destination_x-1.0 )){
				dest_reached = 1;
				stop();
			}
		}
	}
	mtrs = 0;
	stop();
}

void odometry_go_y(int distance, int direction=1)
{
	int dest_reached;
	int direction_x, direction_y;
	BotLocation pos;
	// ogo.destination_x = dest_x;
	ogo.destination_y = distance;
	ogo.movement_timeout = 1000;
	dest_reached = 0;
	reset_odometry();
		pos.x_pos = 0;
	pos.y_pos = 0;
	clearTimer(T1);
	while(time1(T1) < ogo.movement_timeout && dest_reached == 0)
	{
		get_botlocation(&pos);
		while(!between(pos.y_pos, ogo.destination_y+1.0,ogo.destination_y-1.0 ) )
		{
			get_botlocation(&pos);
			writeDebugStreamLine("odom y %f %f %f %f\r",pos.x_pos,pos.y_pos,ogo.destination_y+1.0,ogo.destination_y-1.0);
			if (motor[rFront]== 0){
				if (ogo.destination_y > pos.y_pos)
				{
					forward();
				}
				else
				{
					reverse();
				}
			}
			//		if(! ((abs(pos.y_pos) < abs(ogo.destination_y -1.0))||(abs(pos.y_pos) > abs(ogo.destination_y +1.0))) ){
			if( between(pos.y_pos, ogo.destination_y+1.0,ogo.destination_y-1.0 )){
				dest_reached = 1;
				stop();

			}
		}
	}
}
void odometry_go_x(int distance, int direction=1)
{
	int dest_reached;
	int direction_x, direction_y;
	BotLocation pos;
	// ogo.destination_x = dest_x;
	ogo.destination_x = distance;
	ogo.movement_timeout = 1000;
	dest_reached = 0;
		reset_odometry();
	clearTimer(T1);
	botpos.x_pos = 0;
	botpos.y_pos = 0;
	while(time1(T1) < ogo.movement_timeout && dest_reached == 0)
	{
		get_botlocation(&pos);
		while(!between(pos.x_pos, ogo.destination_x+1.0,ogo.destination_x-1.0 ) )
		{
			get_botlocation(&pos);
			writeDebugStreamLine("odom x %f %f %f %f\r",pos.x_pos,pos.y_pos,ogo.destination_y+1.0,ogo.destination_y-1.0);
			if (motor[rFront]== 0){
				if (direction == 1)
				{
					left();
				}
				else
				{
					right();
				}
			}
			//		if(! ((abs(pos.y_pos) < abs(ogo.destination_y -1.0))||(abs(pos.y_pos) > abs(ogo.destination_y +1.0))) ){
			if( between(pos.y_pos, ogo.destination_x+1.0,ogo.destination_x-1.0 )){
				dest_reached = 1;
				stop();

			}
		}
	}
}



task main()
{
	clearDebugStream();
	BotLocation p;
	init_odometry(xEncoder,yEncoder,9.42,360.0,360.0,neg,neg);
	init_odometry_go(lFront,lBack,rFront,rBack);


	SensorType[in2] = sensorNone;
	wait1Msec(1000);
	SensorType[in2] = sensorGyro;
	wait1Msec(2000);

	process();

	//odometry_go_y(24);
	//odometry_go_x(30,1);
	odometry_go_execute(0,24);
	odometry_go_execute(30,24);
	odometry_go_execute(30, 0);
	odometry_go_execute(0,0);

	SensorValue[gyro]=0;
	//	forward();

	while(1==1)
	{
	writeDebugStreamLine("Rotation - %f",(SensorValue[in2]/10.0) * (90.0/70.0));
	}

}
